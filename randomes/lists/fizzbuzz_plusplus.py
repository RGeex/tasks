"""
Существует распространенная проблема, с которой сталкиваются интервьюируемые в программном
обеспечении. Он называется FizzBuzz. Это работает следующим образом: Для чисел от 1 до 100
выведите fizz, если оно кратно 3, и buzz, если оно кратно 5, иначе выведите само число.

Вы находитесь на собеседовании, и вас просят завершить fizzbuzz (что можно сделать в
однострочном тексте за несколько языков), и вы выбиваете его из парка.

Удивленный вашими способностями, интервьюер предлагает вам более сложную задачу.
Дан список взаимно простых чисел (то есть НОД всех чисел == 1) и список слов одинакового
размера. вычислить его шипучее представление до тех пор, пока образец строк не повторится.

Вот пример:
fizzbuzz_plusplus([2, 3, 5], ['fizz', 'buzz', 'bazz']); // => [1, 'fizz', 'buzz', 'fizz', 'bazz',
'fizzbuzz', 7, 'fizz', 'buzz', 'fizzbazz', 11, 'fizzbuzz', 13, 'fizz', 'buzzbazz', 'fizz', 17,
'fizzbuzz', 19, 'fizzbazz', 'buzz', 'fizz', 23, 'fizzbuzz', 'bazz', 'fizz', 'buzz', 'fizz', 29,
'fizzbuzzbazz']

Что следует отметить:

    Ваша функция должна возвращать массив выходных данных для каждого индекса, а не печатать его.
    Если элементы имеют индекс 1, 10-й элемент — это fizz + bazz, как 10 == 0 (модуль 2) и 10 == 0
    (модуль 5).
    Строки всегда объединяются слева направо, образуя массив.
    Массив чисел не всегда можно отсортировать — просто используйте заданный порядок чисел.
    Все числа в первом массиве всегда будут взаимно простыми. Это безопасное предположение для
    вашей программы.
    Список останавливается на месте, потому что если бы вы отфильтровали числа, оставшиеся строки
    повторились бы после этой точки.

Подсказка: как связаны числа, указанные в списке, и длина списка?

"""
from operator import mul
from functools import reduce


def fizzbuzz_plusplus(n: list[int], w: list[str]) -> list[int | str]:
    """
    Создает последовательность FizzBuzz до тех пор пока не будут список
    данных чисел не будет кратен N.
    """
    return [''.join(b for a, b in zip(n, w) if not x % a) or x for x in range(1, reduce(mul, n) + 1)]


def test() -> None:
    """
    Тестирование работы алгоритмов.
    """
    data = (
        (([3, 5], ['fizz', 'buzz']),
         [1, 2, 'fizz', 4, 'buzz', 'fizz', 7, 8, 'fizz', 'buzz', 11, 'fizz', 13, 14, 'fizzbuzz']),

        (([2, 3, 5], ['fizz', 'buzz', 'bazz']),
         [1, 'fizz', 'buzz', 'fizz', 'bazz', 'fizzbuzz', 7, 'fizz', 'buzz', 'fizzbazz', 11, 'fizzbuzz',
         13, 'fizz', 'buzzbazz', 'fizz', 17, 'fizzbuzz', 19, 'fizzbazz', 'buzz', 'fizz', 23, 'fizzbuzz',
         'bazz', 'fizz', 'buzz', 'fizz', 29, 'fizzbuzzbazz']),
    )
    for key, val in data:
        assert fizzbuzz_plusplus(*key) == val


if __name__ == '__main__':
    test()
