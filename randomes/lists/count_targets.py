"""
Из Википедии : «Задание n-back — это задача на непрерывную производительность,
которая обычно используется в качестве оценки в когнитивной нейробиологии для
измерения части рабочей памяти и объема рабочей памяти. [...] Субъекту
предъявляется последовательность стимулов. , а задача состоит в том, чтобы
указать, когда текущий стимул соответствует стимулу из nшаги ранее в
последовательности. Коэффициент нагрузки nможно скорректировать, чтобы сделать
задачу более или менее сложной».

В этой ката ваша задача — «научить» компьютер выполнять задачу n-back.
В частности, вы будете реализовывать функцию, которая подсчитывает количество «мишеней»
(стимулов, соответствующих стимулу из n шаги ранее) в последовательности цифр.

Ваша функция будет принимать два параметра:

    n, положительное целое число: количество шагов, которые необходимо выполнить, чтобы
    найти совпадение.
    sequence, последовательность цифр, содержащая 0или несколько целей

Несколько советов:

    Первая цифра в последовательности никогда не может быть целью
    Цели могут быть «связаны» вместе (например, для n = 1и sequence = [1, 1, 1], есть 2цели)
"""


def count_targets(n: int, arr: list[int]) -> int:
    """
    Подсчитывает кол-во повторение в списке, через заданный шаг.
    """
    return sum(a == b for a, b in zip(arr, arr[n:]))


def test() -> None:
    """
    Тестирование работы алгоритмов.
    """
    data = (
        ((1, [1, 1, 1, 1, 1]), 4),
        ((2, [1, 1, 1, 1, 1]), 3),
        ((1, [1, 2, 1, 2, 1]), 0),
        ((2, [1, 2, 1, 2, 1]), 3),
        ((9, [1, 2, 3, 4, 5, 6, 7, 8, 9, 1]), 1),
        ((1, []), 0),
        ((1, [1] * 1001), 1000),
        ((1000, [1] * 1001), 1),
    )
    for key, val in data:
        assert count_targets(*key) == val


if __name__ == '__main__':
    test()
