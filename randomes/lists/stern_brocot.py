"""
Последовательность Штерна-Броко во многом похожа на последовательность Фибоначчи и имеет некоторые
интересные последствия. Давайте узнаем об этом:

Это начинается с [1, 1]и добавляет два новых термина на каждой итерации: nextTermчто является
суммой предыдущей пары; и termAfterThatчто является вторым членом этой предыдущей пары.
Вот как найти эти термины:

[1, 1] + [nextTerm: 1 + 1 = 2; termAfterThat: 1] ==> [1, 1, 2, 1]
 ^  ^

Затем вы сдвигаете пары с одним индексом в последовательности:

[1, 1, 2, 1] + [1 + 2, 2] ==> [1, 1, 2, 1, 3, 2]
    ^  ^

И так далее... если сделать это еще на 2 итерации, получится:

[1, 1, 2, 1, 3, 2, 3, 1, 4, 3]

Завершите код, который принимает положительное целое число nи возвращает индекс первого вхождения
n в последовательности. Примечание: индексация начинается с нуля.
Примеры

[1, 1, 2, 1, 3, 2, 3, 1, 4, 3, ...]
       ^     ^           ^
n = 2 ==> 2 
n = 3 ==> 4
n = 4 ==> 8
"""


def stern_brocot(n: int) -> int:
    """
    Поиск индекса первого заданного элемента в последовательности.
    """
    r, i = [1, 1], 0
    while n not in r:
        i += not r.extend([sum(r[i:i+2]), r[i+1]])
    return r.index(n)


def test() -> None:
    """
    Тестирование работы алгоритмов.
    """
    data = (
        (2, 2),
        (3, 4),
        (10, 38),
        (8, 20),
        (19, 82),
    )
    for key, val in data:
        assert stern_brocot(key) == val


if __name__ == '__main__':
    test()
