"""
В компьютерной операционной системе, использующей страничную организацию памяти для управления
виртуальной памятью, алгоритмы замещения страниц определяют, какие страницы памяти следует
выгрузить, когда необходимо выделить страницу памяти. Замещение страниц происходит, когда
запрошенная страница отсутствует в памяти (ошибка страницы), и свободная страница не может
быть использована для удовлетворения запроса на выделение памяти, либо потому что их нет,
либо потому что количество свободных страниц меньше определенного порогового значения.
Алгоритм замещения страниц FIFO

Алгоритм замещения страниц «первым вошел — первым вышел» (FIFO) — это алгоритм с низкими накладными
расходами, требующий минимального учета со стороны операционной системы. Идея очевидна из названия:
операционная система отслеживает все страницы в памяти в очереди, при этом самая последняя поступившая
страница находится в конце, а самая старая — в начале. Когда необходимо заменить страницу, выбирается
самая старая страница. Следует отметить, что страница, уже находящаяся в очереди, не помещается в
конец очереди, если к ней обращаются повторно.

Ваша задача — реализовать этот алгоритм. Функция будет принимать на вход два параметра: максимальное
количество страниц, которые могут одновременно храниться в памяти. nи а reference listСодержит числа.
Каждое число представляет собой запрос страницы (это число можно рассматривать как уникальный
идентификатор страницы). Ожидаемый результат — состояние памяти после применения алгоритма.
Обратите внимание, что после вставки страницы в память она остается на том же месте до тех пор,
пока не будет удалена из памяти в результате ошибки страничного доступа.
Пример:

Данный:

    N = 3,
    СПИСОК ЛИТЕРАТУРЫ = [1, 2, 3, 4, 2, 5],

  * 1 is read, page fault --> memory = [1];
  * 2 is read, page fault --> memory = [1, 2];
  * 3 is read, page fault --> memory = [1, 2, 3];
  * 4 is read, page fault --> memory = [4, 2, 3];
  * 2 is read, already in memory, nothing happens;
  * 5 is read, page fault --> memory = [4, 5, 3].

Итак, в итоге у нас есть список. [4, 5, 3]Именно это вам и нужно вернуть. Если после применения алгоритма
не все ячейки памяти будут заняты, заполните оставшиеся ячейки (в конце списка) значением . -1
для обозначения пустоты (обратите внимание, что идентификаторы всегда будут >= 1).

"""
import unittest
from typing import Any, Callable, List, Tuple


def fifo(n: int, reference_list: List[int]) -> List[int]:
    """
    Вычисляет страницы сохраненные в память в конце чтения списка страниц.
    """
    res, i = [-1] * n, 0
    for x in reference_list:
        if x not in res:
            res[i], i = x, (i + 1) % n
    return res


def test(func: Callable[[Any], Any], data: Tuple[Tuple[Any, Any], ...]) -> None:
    """Тестирование работы алгоритмов с помощью unittest."""

    def test_func(func: Callable[[Any], Any], key: Any, val: Any) -> Callable[[Any], Any]:
        """Создает кейсы для тестирования."""
        return lambda self: self.assertEqual(func(*key), val)

    funcs = {f'test_{i}': test_func(func, key, val) for i, (key, val) in enumerate(data, 1)}
    suite = unittest.TestLoader().loadTestsFromTestCase(type('Tests', (unittest.TestCase,), funcs))

    unittest.TextTestRunner().run(suite)


if __name__ == '__main__':
    test(fifo, (
        ((3, [1, 2, 3, 4, 2, 5]), [4, 5, 3]),
        ((5, []), [-1, -1, -1, -1, -1]),
        ((4, [1, 2, 3, 3, 4, 5, 1]), [5, 1, 3, 4]),
        ((4, [1, 1, 1, 2, 2, 3]), [1, 2, 3, -1]),
        ((1, [5, 4, 3, 3, 4, 10]), [10]),
        ((3, [1, 1, 1, 1, 1, 1, 1, 1]), [1, -1, -1]),
        ((5, [10, 9, 8, 7, 7, 8, 7, 6, 5, 4, 3, 4, 3, 4, 5, 6, 5]), [5, 4, 3, 7, 6]),
    ))
