"""
Ваша задача — реализовать функцию, которая берет один или несколько
словарей и объединяет их в один результирующий словарь.

Ключи в данных словарях могут перекрываться. В этом случае вам следует
объединить все исходные значения в массив. Повторяющиеся значения должны быть сохранены.

Вот пример:

source1 = {"A": 1, "B": 2} 
source2 = {"A": 3}

result = merge(source1, source2);
// result should have this content: {"A": [1, 3]}, "B": [2]}

Вы можете предположить, что в вашу функцию передаются только действительные словари.
Число данных словарей может быть большим. Так что позаботьтесь о производительности.
"""


def merge(*dicts: dict) -> dict:
    """
    Объединение словарей, сохраняя значения в список.
    """
    r = {}
    for x in dicts:
        for k, v in x.items():
            r[k] = r.get(k, []) + [v]
    return r


def test() -> None:
    """
    Тестирование работы алгоритмов.
    """
    data = (
        (({}, {}, {}), {}),
        (({"A": 1, "B": 2, "C": 3}, {"A": 5, "D": 6}, {"E": 7, "F": 8}, {"E": 9, "A": 1}),
         {"A": [1, 5, 1], "B": [2], "C": [3], "D": [6], "E": [7, 9], "F": [8]}),
        (({"A": 1, "B": 2, "C": 3}, {"A": 4, "D": 5}, {}, {"E": 6, "D": 7}),
         {"A": [1, 4], "B": [2], "C": [3], "D": [5, 7], "E": [6]}),
        (({True: "A", False: "B"}, {True: "C", False: "D"}, {True: "E"}),
         {True: ["A", "C", "E"], False: ["B", "D"]}),
        (({"A": 1, "B": 2, "C": 3},), {"A": [1], "B": [2], "C": [3]}),
        (({"A": 1}, {"B": 2}), {"A": [1], "B": [2]}),
        (({"A": 1, "B": 2, "C": 3}, {"A": 4, "D": 5}), {"A": [1, 4], "B": [2], "C": [3], "D": [5]}),
    )
    for key, val in data:
        assert merge(*key) == val


if __name__ == '__main__':
    test()
