"""
Хорошо, детектив, один из наших коллег успешно заметил нашу жертву,
грабителя Робби. Мы последовали за ним на секретный склад, где и
предполагаем найти все украденные вещи. Дверь этого склада защищена
электронным кодовым замком. К сожалению, наш шпион не уверен в ПИН-коде,
который он видел, когда Робби ввел его.

Клавиатура имеет следующую раскладку:

┌───┬───┬───┐
│ 1 │ 2 │ 3 │
├───┼───┼───┤
│ 4 │ 5 │ 6 │
├───┼───┼───┤
│ 7 │ 8 │ 9 │
└───┼───┼───┘
    │ 0 │
    └───┘

Он отметил PIN-код 1357, но он также сказал, что возможно, что каждая из
увиденных им цифр на самом деле могла быть другой соседней цифрой
(по горизонтали или вертикали, но не по диагонали). Например, вместо 1
это также может быть 2 или 4. И вместо 5 это также может быть 2, 4, 6или 8.

Он также упомянул, что знает такие замки. Вы можете ввести неограниченное
количество неправильных PIN-кодов, они никогда окончательно не заблокируют
систему и не подадут сигнал тревоги. Вот почему мы можем опробовать все
возможные (*) варианты.

* возможно в смысле: самого наблюдаемого ПИН-кода и всех его вариантов с
учетом соседних цифр.

Можете ли вы помочь нам найти все эти варианты? Было бы неплохо иметь функцию,
возвращающую массив (или список в Java/Kotlin и C#) всех вариантов наблюдаемого
PIN-кода длиной от 1 до 8 цифр. Но обратите внимание, что все ПИН-коды,
как наблюдаемый, так и результаты, должны быть строками, поскольку потенциально
могут начинаться с нулей. Мы уже подготовили для вас несколько тестовых примеров.

Детектив, мы рассчитываем на вас!
"""

from operator import eq
from itertools import product


def get_pins(com: str) -> list[str]:
    """
    Поиск похожих комбинаций паролей, по 1 из возможных.
    """
    arr = '80 124 1235 236 1457 24568 3569 478 57890 689'.split()
    return list(map(''.join, product(*[arr[int(x)] for x in com])))


def test() -> None:
    """
    Тестирование работы алгоритмов.
    """
    data = (
        ('8', ['5', '7', '8', '9', '0']),
        ('11', ["11", "22", "44", "12", "21", "14", "41", "24", "42"]),
        ('369', [
            "339", "366", "399", "658", "636", "258", "268", "669", "668", "266", "369", "398",
            "256", "296", "259", "368", "638", "396", "238", "356", "659", "639", "666", "359",
            "336", "299", "338", "696", "269", "358", "656", "698", "699", "298", "236", "239",
        ]),
    )
    for key, val in data:
        assert eq(*map(sorted, (get_pins(key), val)))


if __name__ == '__main__':
    test()
