"""
Вам нужно написать метод, который сворачивает заданный 
массив целых чисел в среднее значение x раз.

Пример говорит больше, чем тысяча слов: 
Fold 1-times:
[1,2,3,4,5] -> [6,6,3]

A little visualization (NOT for the algorithm but for the idea of folding):

 Step 1         Step 2        Step 3       Step 4       Step5
                     5/           5|         5\ 
                    4/            4|          4\ 
1 2 3 4 5      1 2 3/         1 2 3|       1 2 3\       6 6 3
----*----      ----*          ----*        ----*        ----*


Fold 2-times:
[1,2,3,4,5] -> [9,6]

Как видите, если количество чисел нечетное, среднее число останется.
В противном случае точка сгиба находится между средними числами, поэтому
все числа будут каким-то образом складываться.
Массив всегда будет содержать числа и никогда не будет нулевым.
Параметр num всегда будет положительным целым числом, большим 0,
и указывает, сколько циклов свертывания должен выполнить ваш метод.
Если массив с одним элементом свернуть, он останется тем же массивом.
"""

from itertools import zip_longest


def fold_array(arr: list[int], num: int) -> list[int]:
    """
    Сворачивает массив вычисляя значения.
    """
    x = len(arr) // 2
    for _ in range(num):
        x = len(arr) // 2
        arr = [sum(x) for x in zip_longest(arr[:x], arr[x:][::-1], fillvalue=0)]
    return arr


def test() -> None:
    """
    Тестирование работы алгоритмов.
    """
    data = (
        (([1, 2, 3, 4, 5], 1), [6, 6, 3]),
        (([1, 2, 3, 4, 5], 2), [9, 6]),
        (([1, 2, 3, 4, 5], 3), [15]),
        (([-9, 9, -8, 8, 66, 23], 1), [14, 75, 0]),
    )
    for key, val in data:
        assert fold_array(*key) == val


if __name__ == '__main__':
    test()
