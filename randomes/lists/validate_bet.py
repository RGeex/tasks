"""
История
Вас попросили написать простой валидатор для компании, которая планирует ввести
ставки на лотерею с помощью текстовых сообщений. Один и тот же валидатор будет
использоваться для нескольких игр: например, 5 из 90, 7 из 35 и т. д. (N из M)

Текстовые сообщения должны содержать ровно N уникальных чисел от 1 до M
(включая оба), разделенных запятой (,) и/или пробелами. Любой другой символ
делает ставку недействительной.

Твое задание
На вход вы получаете тип игры и текстовое сообщение пользователя, и вам нужно
проверить, действительна ли ставка или нет.  Если это допустимо, верните
выбранные числа в виде списка, отсортированного в порядке возрастания. Если он
недействителен, верните None, null, nil в соответствии с вашим языком.

Примечание. Начальные и конечные пробелы не проверяются. Табуляции, новые
строки и другие пробелы также не проверяются.  Подумайте о классическом
пользователе Nokia 3310 для справки :-)
"""

import re


def validate_bet(game: list[int], text: str) -> None:

    symbols = re.split(r'[, ]+', text)

    # поиск дубликатов и проверка кол-ва символов
    if len(set(map(len, (symbols, set(symbols)))) | {game[0], }) == 1:
        result = []
        for num in symbols:
            # проверка что символ чдиапазоне
            if not num.isdigit() or int(num) not in range(1, game[1] + 1):
                return None
            result.append(int(num))

        return sorted(result)


def test() -> None:
    """Тестирование работы алгоритмов."""
    data = [
        [[[5, 90], "1, 2, 3, 4"], None],
        [[[5, 90], "1, 2, 3; 4, 5"], None],
        [[[5, 90], "1, 2, 3, 4, 95"], None],
        [[[5, 90], "1 2 3 4 5"], [1, 2, 3, 4, 5]],
        [[[5, 90], "5 , 3, 1  4,2"], [1, 2, 3, 4, 5]],
    ]

    for key, val in data:
        assert validate_bet(*key) == val


if __name__ == '__main__':
    test()
