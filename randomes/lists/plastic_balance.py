"""
Вы получите список с несколькими разбросанными числами.

Необходимо убедиться, что сумма значений с обеих сторон равна сумме остальных элементов списка.

А если нет, удалите два элемента по бокам и проверьте еще раз.

до тех пор, пока не дойдете до контрольного списка условий:

Сумма элементов списка без учета сторон равна сумме элементов списка.

Если значение никогда не равно, вернуть пустой список [].

note: list length can be up to 500 items
Пример:

Пример 1:

[1,2,3,4,5] ==> 1+5 != 2+3+4 ==> [2,3,4] ==> 2+4 != 3 == [3] ==> 3+3 != 0 ==> []

Примечание: (3+3), потому что 3 — это первая и последняя стороны... (!= 0),
потому что сумма списка без сторон равна 0.

Пример 2:

[0,104,3,101,0,111] ==> 0+111 != 104+3+101+0 ==> [104,3,101,0] ==> 104+0 = 3+101 ==> [104,3,101,0]

Пример 3:

[1,-1] ==> 1-1 = 0 ==> [1,-1]

Примечание: (1-1), потому что 1 — первая сторона, а -1 — последняя сторона... (= 0),
потому что сумма списка без сторон (1, -1) = 0

"""
import unittest
from typing import Any, Callable, List, Tuple


def plastic_balance(lst: List[int]) -> List[int]:
    """
    Сранивает сумму крайних элементов списка с его серединой, рукурсивно, убирая не соответствия.
    """
    return plastic_balance(lst[1:-1]) if lst and sum(lst[::len(lst) - (len(lst) > 1)]) != sum(lst[1:-1]) else lst


def test(func: Callable[[Any], Any], data: Tuple[Tuple[Any, Any], ...]) -> None:
    """Тестирование работы алгоритмов с помощью unittest."""

    def test_func(func: Callable[[Any], Any], key: Any, val: Any) -> Callable[[Any], Any]:
        """Создает кейсы для тестирования."""
        return lambda self: self.assertEqual(func(key), val)

    funcs = {f'test_{i}': test_func(func, key, val) for i, (key, val) in enumerate(data, 1)}
    suite = unittest.TestLoader().loadTestsFromTestCase(type('Tests', (unittest.TestCase,), funcs))

    unittest.TextTestRunner().run(suite)


if __name__ == '__main__':
    test(plastic_balance, (
        ([1, 2, 3, 4, 5], []),
        ([0, 104, 3, 101, 0, 111], [104, 3, 101, 0]),
        ([1, -1], [1, -1]),
        ([0], [0]),
        ([100, 0, -100], [100, 0, -100]),
        ([4, 4], []),
    ))
