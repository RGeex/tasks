"""
Вам дан список/массив, который содержит только целые числа (положительные и отрицательные).
Ваша задача — суммировать только одинаковые и последовательные числа. В результате должен
получиться один список.

Дополнительный балл, если вы решите задачу в одну строку. Вы можете предположить, что
пустого списка/массива никогда не бывает и всегда будет целое число.

То же значение: 1 == 1

1 != -1

#Примеры:

[1,4,4,4,0,4,3,3,1] # should return [1,12,0,4,6,1]


So as you can see sum of consecutives 1 is 1 
sum of 3 consecutives 4 is 12 
sum of 0... and sum of 2 
consecutives 3 is 6 ...

[1,1,7,7,3] # should return [2,14,3]
[-5,-5,7,7,12,0] # should return [-10,14,12,0]
"""


from itertools import groupby as gb


def sum_consecutives(lst: list) -> list:
    """
    Из переданного списка чисел, создает новый, объединяя
    следующие подряд одинаковые значение в их сумму.
    """
    return [sum(x) for _, x in gb(lst)]


def test() -> None:
    """
    Тестирование работы алгоритмов.
    """
    data = (
        ([3, 3, 3, 3, 1],[12, 1]),
        ([0, 1, 1, 2, 2],[0, 2, 4]),
        ([1, 1, 1, 1, 1, 3],[5, 3]),
        ([1, 1, 7, 7, 3],[2, 14, 3]),
        ([-5, -5, 7, 7, 12, 0],[-10, 14, 12, 0]),
        ([1, 4, 4, 4, 0, 4, 3, 3, 1],[1, 12, 0, 4, 6, 1]),
        ([1, -1, -2, 2, 3, -3, 4, -4],[1, -1, -2, 2, 3, -3, 4, -4]),
        ([2, 2, -4, 4, 5, 5, 6, 6, 6, 6, 6, 1],[4, -4, 4, 10, 30, 1]),
    )
    for key, val in data:
        assert sum_consecutives(key) == val


if __name__ == '__main__':
    test()
