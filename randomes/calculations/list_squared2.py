"""
1, 246, 2, 123, 3, 82, 6, 41 являются делителями числа 246.
Возведя эти делители в квадрат, получим: 1, 60516, 4, 15129,
9, 6724, 36, 1681. Сумма этих квадратов равна 84100 который 290 * 290.
Задача

Найдите все целые числа между m и n (m и n целых чисел с 1 <= m <= n)
такие, что сумма их квадратов делителей сама является квадратом.

Мы вернем массив подмассивов или кортежей (в C — массив пар) или строку.
Подмассивы (или кортежи, или пары) будут состоять из двух элементов:
сначала числа, квадраты делителей которого являются квадратами,
а затем сумма квадратов делителей.
Пример:

list_squared(1, 250) --> [[1, 1], [42, 2500], [246, 84100]]
list_squared(42, 250) --> [[42, 2500], [246, 84100]]

Форма примеров может меняться в зависимости от языка, см. «Примеры тестов».
Примечание

В Фортране, как и в любом другом языке, возвращаемая строка не может содержать
избыточные конечные пробелы: вы можете использовать динамически выделяемые
строки символов.
"""


def list_squared(a: int, b: int) -> list[list[int]]:
    """
    Поиск чисел в заданном диапазоне, сумма квадратов делителей которого,
    является квадратом числа.
    """
    res = []
    for n in range(a, b + 1):
        x, c = 0, 1
        while c <= (y := divmod(n, c))[0]:
            x, c = x + (c ** 2 + ((y[0] != c and y[0] ** 2)) if not y[1] else 0), c + 1
        if (x ** .5).is_integer():
            res.append([n, x])
    return res


def test() -> None:
    """
    Тестирование работы алгоритмов.
    """
    data = (
        ((1, 250), [[1, 1], [42, 2500], [246, 84100]]),
        ((42, 250), [[42, 2500], [246, 84100]]),
        ((250, 500), [[287, 84100]]),
    )
    for key, val in data:
        assert list_squared(*key) == val


if __name__ == '__main__':
    test()
