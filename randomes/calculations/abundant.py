"""
В теории чисел обильное или избыточное число — это число, у которого сумма собственных делителей
больше самого числа. Целое число 12 — первое обильное число.
Его собственные делители — 1, 2, 3, 4 и 6, всего 16 . Величина, на которую сумма превышает число,
и есть изобилие . число 12 имеет изобилие 4 Например:
Другие исходные числа: 12, 18, 20, 24, 30, 36, 40, 42, 48, 54 и т. д. Существует бесконечно много
нечетных и четных обильных чисел.
Как вы уже догадались, в этом ката ваша функция примет положительное целое число h в качестве
входных данных диапазона и вернет вложенный массив/список, который будет содержать следующую
информацию:

    Максимальное доступное нечетное или четное избыточное число в этом диапазоне.
    Это изобилие

Примеры

Несколько примеров никому не повредят, правда???

abundant(15)  = [[12], [4]]
abundant(19)  = [[18], [3]]
abundant(100) = [[100], [17]]
abundant(999) = [[996], [360]]

Советы

Проблема связана с довольно большими случайными числами. Поэтому постарайтесь оптимизировать свой
код для повышения производительности, насколько это возможно. И да, входной аргумент всегда будет
положительным целым числом. Так что не надо там проверять.
"""


def abundant(h: int) -> list:
    """
    Поиск ближайшего наименьшего числа избыточного числа, а так же избыток.
    """
    return next(([[x], [n - x]] for x in range(h, 0, -1) if x < (n := sum(i for i in range(1, x) if not x % i))), 0)


def test() -> None:
    """
    Тестирование работы алгоритмов.
    """
    data = (
        (15, [[12], [4]]),
        (19, [[18], [3]]),
        (100, [[100], [17]]),
        (999, [[996], [360]]),
        (200, [[200], [65]]),
        (250, [[246], [12]]),
        (300, [[300], [268]]),
        (350, [[350], [44]]),
        (400, [[400], [161]]),
        (450, [[450], [309]]),
        (500, [[500], [92]]),
        (555, [[552], [336]]),
        (600, [[600], [660]]),
        (666, [[666], [150]]),
        (707, [[704], [116]]),
        (777, [[774], [168]]),
        (800, [[800], [353]]),
        (900, [[900], [1021]]),
        (1111, [[1110], [516]]),
    )
    for key, val in data:
        assert abundant(key) == val


if __name__ == '__main__':
    test()
