"""
Принцип довольно прост:

    Учитывая целое число (n)
    Найдите следующее палиндромное число после (исключая) n

Реализуйте это в функции nextPalin.

Однако из-за некоторых ограничений реализация не является:

    0 < п < 10^1000
    0 < т < 0,175 с

АКА

    n может содержать от 1 до 1001 цифры
    общее время для всех тестовых случаев должно быть меньше 0,175 с (175 мс)

Это означает, что вы не можете:

def next_palin(n):
  while not is_palin(n): #is_palin() defined elsewhere
    n += 1
  return n

"""


def next_palin(num: int) -> int:
    """
    Поиск следующего ближайшего числа палиндрома.
    """
    x = str(num)
    m, n = divmod(len(x), 2)
    a, b, c = x[:m][::-1], x[m+n:], x[m:m+n]

    if a and b:
        n = str(int(a[::-1]) + (a <= b and (not c or c == '9')))

        if len(a) < len(n):
            n = '1' + '0' * (len(a) - (not c))
            c = '9' if not c else ''

        return int(''.join([n, c and str(int(c) + (a <= b))[-1], n[::-1]]))
    return num + 1 if num + 1 < 10 else 11


def test() -> None:
    """
    Тестирование работы алгоритмов.
    """
    data = (
        (2, 3),
        (9, 11),
        (12, 22),
        (54, 55),
        (36, 44),
        (134, 141),
        (11, 22),
        (1234, 1331),
        (1212, 1221),
        (12345, 12421),
        (123456787654, 123457754321),
        (9876543219123456789, 9876543220223456789),
        (12399333, 12400421),
        (1239333, 1240421),
        (1239125, 1239321),
        (12399125, 12399321),
        (9999, 10001),
        (99999, 100001),
        (10, 11),
        (100, 101),
    )
    for key, val in data:
        assert next_palin(key) == val


if __name__ == '__main__':
    test()
