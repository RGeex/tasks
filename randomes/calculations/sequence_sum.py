"""
Задачу объяснить просто: просто просуммируйте все числа от первого параметра,
являющегося началом, до второго параметра, являющегося верхним пределом
(возможно, включенным), идя шагами, выраженными третьим параметром:

sequence_sum(2, 2, 2) # 2
sequence_sum(2, 6, 2) # 12 (= 2 + 4 + 6)
sequence_sum(1, 5, 1) # (= 1 + 2 + 3 + 4 + 5)
sequence_sum(1, 5, 3) # 5 (= 1 + 4)

Если это невозможная последовательность (начало больше конца и положительный
шаг или наоборот), просто верните 0. Дополнительные примеры см. в
предоставленных тестовых примерах.

Будут протестированы гораздо большие диапазоны, поэтому вам следует надеяться
на оптимизацию вашего алгоритма и избежать грубого подхода к решению.
"""


def sequence_sum(start: int, stop: int, step: int) -> int:
    """
    Вычисляет сумму диапозона значений.
    """
    if (step == 0) or (step > 0 and start > stop) or (step < 0 and start < stop):
        return 0
    num_elements = (stop - start) // step + 1
    return (start + start + (num_elements - 1) * step) * num_elements // 2


def test() -> None:
    """
    Тестирование работы алгоритмов.
    """
    data = (
        ((2, 6, 2), 12),
        ((1, 5, 1), 15),
        ((1, 5, 3), 5),
        ((-1, -5, -3), -5),
        ((16, 15, 3), 0),
        ((-24, -2, 22), -26),
        ((-2, 4, 658), -2),
        ((780, 6851543, 5), 4694363402480),
        ((9383, 71418, 2), 1253127200),
        ((20, 673388797, 5),  45345247259849570),
    )
    for key, val in data:
        assert sequence_sum(*key) == val


if __name__ == '__main__':
    test()
