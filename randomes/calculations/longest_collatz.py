"""
Предыстория – гипотеза Коллатца:

Представьте, что вам дано положительное целое число, n, затем:
    если nчетно, вычислите: n / 2
    если nнечетно, вычислите: 3 * n + 1

Повторяйте, пока не получите ответ 1. Гипотеза Коллатца утверждает, что
выполняя эту операцию неоднократно, вы всегда в конечном итоге достигнете 1.


Учитывая массив положительных целых чисел, верните целое число, чья
последовательность Коллатца является самой длинной.

Пример:
longest_collatz([2, 4, 3])==3

Пояснение: Последовательность Коллатца
для 2 имеет длину 1,
для 4 имеет длину 2,
для 3 имеет длину 7.

Итак, из нашего массива целое число 3имеет
самую длинную последовательность Коллатца.

Следовательно, ваша функция должна вернуть 3.
Примечание:

Ответов может быть более одного, т. е. два или более целых числа
дают самую длинную последовательность Коллатца, поскольку у них
есть последовательности одинаковой длины. В этом случае ваша
функция должна возвращать целое число, которое появляется первым в массиве.

Пример: Учитывая массив: [2, 5, 32], оба 5и 32имеют последовательности
Коллатца длины 5. Это также самые длинные последовательности из нашего массива.

В этом случае наша функция возвращает 5, потому что 5 приходит раньше
32 в нашем массиве.
"""


def longest_collatz(input_array: list[int]) -> int:
    """
    Поиск самой длинной последовательности Коллатца.
    """
    def longest(n: int, count: int = 0) -> int:
        def calc(n: int) -> int:
            nonlocal count
            count += 1
            return calc((3 * n + 1) if n % 2 else (n / 2)) if n > 1 else 1
        return calc(n) and count
    return max(input_array, key=longest)


def test() -> None:
    """
    Тестирование работы алгоритмов.
    """
    data = (
        ([2, 4, 3], 3),
        ([1, 5, 27, 4], 27),
        ([64, 64, 27, 64], 27),
        ([75, 226, 113, 340], 75),
        ([340, 113, 226, 75], 75),
        ([75, 113, 226, 75], 75),
    )
    for key, val in data:
        assert longest_collatz(key) == val


if __name__ == '__main__':
    test()
