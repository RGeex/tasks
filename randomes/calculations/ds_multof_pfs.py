"""
Числа 12, 63 и 119 имеют кое-что общее, связанное с их делителями и простыми множителями,
давайте посмотрим.

Numbers PrimeFactorsSum(pfs)        DivisorsSum(ds)              Is ds divisible by pfs
12         2 + 2 + 3 = 7         1 + 2 + 3 + 4 + 6 + 12 = 28            28 / 7 = 4,  Yes
63         3 + 3 + 7 = 13        1 + 3 + 7 + 9 + 21 + 63 = 104         104 / 13 = 8, Yes
119        7 + 17 = 24           1 + 7 + 17 + 119 = 144                144 / 24 = 6, Yes

Вы можете увидеть очевидное свойство: сумма делителей числа делится на сумму его простых
множителей.

Нам нужна функция ds_multof_pfs()который получает два аргумента: nMinи nMaxв качестве
нижнего и верхнего предела (включительно) соответственно и выводит отсортированный
список чисел, соответствующих описанному выше свойству.

Представляем особенности описываемой функции:

ds_multof_pfs(nMin, nMax) -----> [n1, n2, ....., nl] # nMin ≤ n1 < n2 < ..< nl ≤ nMax

Давайте рассмотрим некоторые случаи:

ds_multof_pfs(10, 100) == [12, 15, 35, 42, 60, 63, 66, 68, 84, 90, 95]

ds_multof_pfs(20, 120) == [35, 42, 60, 63, 66, 68, 84, 90, 95, 110, 114, 119]
"""


def ds_multof_pfs(nMin: int, nMax: int) -> list:
    """
    Поиск чисел из диапазона по заданному шаблону поиска.
    """
    res = []
    for num in range(nMin, nMax + 1):
        xdiv, pdiv, temp = 1, 0, num
        for i in range(2, num + 1):
            if not num % i:
                xdiv += i
                while not temp % i:
                    pdiv, temp = pdiv + i, temp // i
        if not xdiv % pdiv:
            res.append(num)
    return res


def test() -> None:
    """
    Тестирование работы алгоритмов.
    """
    data = (
        ((10, 100), [12, 15, 35, 42, 60, 63, 66, 68, 84, 90, 95]),
        ((20, 120), [35, 42, 60, 63, 66, 68, 84, 90, 95, 110, 114, 119]),
    )
    for key, val in data:
        assert ds_multof_pfs(*key) == val


if __name__ == '__main__':
    test()
