"""
Warcraft Series I — Добыча золота

Привет! Ката вдохновлено моей любимой стратегической игрой Warcraft 3, где игроки управляют
юнитами, собирают ресурсы и строят свою базу. Целью этого ката является создание программы,
моделирующей процесс сбора золота из рудника и транспортировки его на базу.

Рабочие назначаются на золотой рудник и автоматически начинают собирать золото с рудника.
Как только рабочий соберет определенное количество золота, он вернется на базу, чтобы
положить золото в здание ратуши.
Вход

    Параметр path представляет собой исходное состояние горнодобывающего месторождения.
    У него есть мина с индексом 0, представленная буквой "M"и основание с индексом 4,
    представленное буквой "B". Первоначально рабочий располагается под индексом 2,
    который находится между шахтой и базой.
    Параметр time— это количество итераций или тактов, которые должна выполнить симуляция.
    Метод принимает входную строку, которая представляет начальное состояние моделирования,
    и моделирует движение рабочих для timesитерации. Результирующее состояние моделирования
    затем преобразуется в список строк, где каждая строка представляет строку сетки.

MiningRepresentation.generate("M..<B", 9);


Выход

Выходные данные представляют собой список или массив строк, представляющих состояние карты после
каждого тика времени, пока время не истечет.

M..<B // Рабочий идет на шахту
 М.<.Б
 М<..Б
 *...B // Рабочий добывает золото
 М>..Б
 М.>.Б
 М..>Б
 М...* // Рабочий принес золото
 М..<Б


Объяснение:

    M- Шахта (место сбора золота)
    B- База (место для принесения золота)
    <или >направление движения рабочих (влево/вправо)
    *- отмечает, что Шахта или База уже занята другим работником
    #- отмечает столкновение (два рабочих на одной плитке)
    Примечание. Шахта и База не могут одновременно содержать более одного рабочего.
    .- Пустой тайл, обозначающий дорогу между шахтой и базой.

Примеры столкновений

    Плавное столкновение

    "М>....<Б"
     "М.>..<.Б"
     "M..><..B" // плавное столкновение
     "М..<>..Б"
     "М.<..>.Б"

    Столкновение на одной плитке

    "М>...<Б"
     "М.>.<.Б"
     "M..#..B" // два рабочих на одной плитке
     "М.<.>.Б"
     "М<...>Б"

Советы:

    Мой всегда будет в индексе 0 и База в last индекс.
    Рабочие всегда тратят один tick/time на базе, в моей или путешествуя на одну ячейку.
    Не будет теста, в котором рабочие появляются при столкновении, на базе или в шахте.
    В настоящее время нет возможности получить случайный ввод, который будет иметь # или
    * в этом. Но принцип очень прост.
        Характер #означает, что два рабочих находятся на одной плитке, один идет направо,
        а другой налево (в противоположном направлении).
        Характер *означает, что работник уже прибыл в одну из точек назначения, поэтому
        он отправится в другую (от меня к базе или наоборот).

Я все еще думаю, стоит ли мне добавить более сложные случайные тесты, которые размещают
рабочих где угодно в начале. Дайте мне знать ваше мнение в обсуждениях.

Для лучшего понимания ознакомьтесь с примерами тестов для каждого случая с комментариями
внутри. Удачи и будьте готовы к работе!
"""


def simulate_mining(path: str, time: int) -> list:
    """
    Состояние карты, на каждом тике.
    """
    res = [path]
    for _ in range(time - 1):
        temp = [[] for _ in range(len(path))]
        for i, v in enumerate(path):
            if v == '*':
                temp[i + [-1, 1][not i]].append([1, 2][not i])
            if v in '#>':
                temp[i + 1].append(2)
            if v in '#<':
                temp[i - 1].append(1)
        path = ''
        for i, v in enumerate(temp):
            if not i or i == len(temp) - 1:
                path += '*' if v else 'BM'[not i]
            else:
                path += '#<>'[sum(v) % 3] if v else '.'
        res.append(path)
    return res


def test() -> None:
    """
    Тестирование работы алгоритмов.
    """
    data = (
        (('M.......B', 5), [
            'M.......B',
            'M.......B',
            'M.......B',
            'M.......B',
            'M.......B',
        ]),
        (('M..<..B', 12), [
            'M..<..B',
            'M.<...B',
            'M<....B',
            '*.....B',
            'M>....B',
            'M.>...B',
            'M..>..B',
            'M...>.B',
            'M....>B',
            'M.....*',
            'M....<B',
            'M...<.B',
        ]),
        (('M..<>..B', 11), [
            'M..<>..B',
            'M.<..>.B',
            'M<....>B',
            '*......*',
            'M>....<B',
            'M.>..<.B',
            'M..><..B',
            'M..<>..B',
            'M.<..>.B',
            'M<....>B',
            '*......*',
        ]),
        (('M.<<<.B', 12), [
            'M.<<<.B',
            'M<<<..B',
            '*<<...B',
            '*#....B',
            '*>>...B',
            'M>>>..B',
            'M.>>>.B',
            'M..>>>B',
            'M...>>*',
            'M....#*',
            'M...<<*',
            'M..<<<B',
        ]),
    )
    for key, val in data:
        assert simulate_mining(*key) == val


if __name__ == '__main__':
    test()
