"""
Вам дана строка s. Это строка, состоящая из букв, цифр или символов.

Ваша задача — найти самую длинную подстроку, состоящую из уникальных символов в sи верните его длину.
Примечание

    1 <= s.length <= 10^7

    5 исправлены тестовые примеры

    100 случайные тестовые случаи, проверка правильности решения

    100 случайные тестовые случаи, тестирование производительности кода

    Все входные данные действительны.

    Обратите внимание на производительность кода.

    Если мое эталонное решение дает неверный результат в случайных тестах, дайте мне знать (сообщите о проблеме).

Пример

Для s="baacab", вывод должен быть 3.

Неповторяющиеся подстроки в s являются:

"b","c","a","ba","ac","ca","ab","cab"

Самый длинный из них "cab", его длина 3.

Для s="abcd", вывод должен быть 4.

Самый длинный из них "abcd", его длина 4.

Для s="!@#$%^&^%$#@!", вывод должен быть 7.

Самая длинная подстрока "!@#$%^&" и "&^%$#@!", их длина равна 7. 
"""


def longest_substring(s : str) -> int:
    """
    Поиск максимальной длины подстроки с уникальными символами.
    """
    return max([len(next((t[:-1] for x in range(i, len(s)) if len(t := s[i:x + 1]) != len(set(t))), s[i:])) for i in range(len(s))], default=0)


def test() -> None:
    """
    Тестирование работы алгоритмов.
    """
    data = (
        ("baacab", 3),
        ("abcd", 4),
        ("hchzvfrkmlnozjk", 11),
        ("!@#$%^&^%$#@!", 7),
        ("abcd" * 10000 + "abcde" + "abcd" * 10000, 5),
    )
    for key, val in data:
        assert longest_substring(key) == val


if __name__ == '__main__':
    test()
