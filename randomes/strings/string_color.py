"""
Имеют ли имена цвета?

Теперь они это делают.

Создайте функцию, которая принимает имя (на самом деле любая строка, состоящая
из двух или более символов, но идея — это имя) и используйте значения ascii ее
подстрок для получения шестнадцатеричного значения ее цвета! Вот как это будет
работать:

    Первые две шестнадцатеричные цифры представляют собой СУММУ значений
    символов (по модулю 256).
    Вторые два — ПРОИЗВЕДЕНИЕ всех символов (опять же по модулю 256, что на
    единицу больше, чем FF в шестнадцатеричном формате).
    Последние два — это АБСОЛЮТНАЯ ЗНАЧЕНИЕ РАЗНИЦЫ между первой буквой и
    суммой всех остальных букв. (Я думаю, вы поняли идею по модулю).

Например "Jack" возвращает "79CAE5", который... нежно-голубой!

"Jack"  #  "J" = 74, "a" = 97, "c" = 99, "k" = 107

74 + 97 + 99 + 107 = 377                   -->  mod 256 = 121  -->  hex: 79
74 * 97 * 99 * 107 = 76036554              -->  mod 256 = 202  -->  hex: CA
74 - (97 + 99 + 107) = -229  --> abs: 229  -->  mod 256 = 229  -->  hex: E5

ПРИМЕЧАНИЕ. Функция должна вернуть None/nil когда ввод меньше двух символов.
"""


from functools import reduce
from operator import add, mul, sub


def string_color(s: str) -> str | None:
    """
    Превращает переданную строку в цвет, если передано менее 2-х символов - None.
    """
    return len(s) > 1 and ''.join([f'{abs(reduce(c, map(ord, s))) % 256:0>2x}' for c in (add, mul, sub)]).upper() or None


def test() -> None:
    """
    Тестирование работы алгоритмов.
    """
    data = (
        ("Jack", "79CAE5"),
        ("John Doe", "C70033"),
        ("CodeWars", "182892"),
        ("X", None),
    )
    for key, val in data:
        assert string_color(key) == val


if __name__ == '__main__':
    test()
