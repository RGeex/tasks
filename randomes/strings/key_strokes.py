"""
Координаты Qwerty - строки

Типичная компоновка клавиатуры Qwerty аналогична этому:

[Q][W][E][R][T][Y][U][I][O][P]
[A][S][D][F][G][H][J][K][L][;][']
[Z][X][C][V][B][N][M][,][.][?]
[ ][ ][   <Space>   ][ ][ ][ ]

(Для этого Kata это единственные персонажи, которые мы используем)

Учитывая список кортежей Длина, где описывает кортеж (x, y) на клавиатуре, и где x и y начинаются с
0, расположенных в [Q]и где [<Space>] Занимает все координаты от (2, 3) до (6, 3) включительно,
создает строку, как если бы она была напечатана на этой клавиатуре. Предположим, что все буквы
являются строчными, за исключением первой буквы в строке, первой буквы после периода или знака
вопроса, и, конечно, буква «I» («Eye») сама по себе (без альфа -символов до или после этого).
(ПРИМЕЧАНИЕ О вопросе-в этом kata нет ключа смены, поэтому предположим, что все ключи-это их не
смещенное вариант, за исключением [/], который должен быть [?], Как показано на диаграмме).
Используйте предоставленные тестовые случаи, если это необходимо, чтобы точно определить, что
само по себе является «само по себе» для буквы I.

Подсказка: для капитализации буквы являются альфа (AZ). Если буква следует загладить после какой-
либо пунктуации, например, после периода, первый альфа -символ после этого периода должен быть
зачислен. Например, «это., Это тест» действителен, «это., Это тест».

Примеры:

key_strokes([(5, 1), (2, 0), (8, 1), (8, 1), (8, 0), (7, 2), (5, 3), (1, 0), (8, 0), (3, 0), (8, 1), (2, 1)])
'Hello, world'

Другие ограничения:

    Помимо координат в диапазоне, представляющем пробел, вы не получите никаких координат со значением AY 3.

    Все строки начнутся с альфа -персонажа.
"""
import typing
import unittest


def key_strokes(keys: list[tuple[int]]) -> str:
    """
    Печатает сообщение переданное клавиатуре.
    """
    res, prew, x, i, n = '', '', "qwertyuiop asdfghjkl;' zxcvbnm,.?".split(), 0, 1

    for a, b in keys + [(0, 3)]:
        curr = x[b][a] if b < 3 else ' '

        i = [i, 0][i and curr.isalpha()]
        i = [i, 1][curr == 'i' and not prew.isalpha()]
        n = [n, 1][prew in '.?']

        if (n and prew.isalpha()) or (i and not curr.isalpha()):
            prew, i, n = prew.upper(), 0, 0

        res, prew = res + prew, curr

    return res


def test(func: typing.Callable, data: tuple[tuple[typing.Any, typing.Any]]) -> None:
    """Тестирование работы алгоритмов с помощью unittest."""

    def test_func(func: typing.Callable, key: typing.Any, val: typing.Any) -> typing.Callable:
        """Создает кейсы для тестирования."""
        return lambda self: self.assertEqual(func(key), val)

    funcs = {f'test_{i}': test_func(func, key, val) for i, (key, val) in enumerate(data, 1)}
    suite = unittest.TestLoader().loadTestsFromTestCase(type('Tests', (unittest.TestCase,), funcs))

    unittest.TextTestRunner().run(suite)


if __name__ == '__main__':
    test(key_strokes, (
        (([(5, 1), (2, 0), (8, 1), (8, 1), (8, 0), (7, 2), (5, 3), (1, 0), (8, 0), (3, 0), (8, 1), (2, 1)]), "Hello, world"),
    ))
