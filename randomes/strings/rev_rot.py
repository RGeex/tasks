"""
Входные данные представляют собой строку strцифр. Разрезать строку на куски
(здесь кусок — это подстрока исходной строки) размером sz
(игнорируйте последний чанк, если его размер меньше sz).

Если сумма цифр фрагмента делится на 2, переверните этот фрагмент;
в противном случае поверните его влево на одну позицию. Соберите вместе
эти измененные фрагменты и верните результат в виде строки.

Если

    sz является <= 0 или если str == ""возвращаться ""
    sz лучше (>) чем длина str невозможно взять кусок по размеру szследовательно, верните "".

Примеры:

("123456987654", 6) --> "234561876549"
("123456987653", 6) --> "234561356789"
("66443875", 4) --> "44668753"
("66443875", 8) --> "64438756"
("664438769", 8) --> "67834466"
("123456779", 8) --> "23456771"
("", 8) --> ""
("123456779", 0) --> "" 
("563000655734469485", 4) --> "0365065073456944"

Example of a string rotated to the left by one position:
s = "123456" gives "234561".
"""

def rev_rot(s: str, n: int) -> str:
    """
    Преобразует строку по заданному алгоритму.
    """
    return ''.join(r[1:] + r[0] if sum(map(int, (r := s[i*n:i*n+n]))) % 2 else r[::-1] for i in range(len(s) // n)) if s and 0 < n else ''


def test() -> None:
    """
    Тестирование работы алгоритмов.
    """
    data = (
        (("", 0), ""),
        (("", 8), ""),
        (("1234", 5), ""),
        (("1234", 0), ""),
        (("123456779", 0), ""),
        (("66443875", 4), "44668753"),
        (("66443875", 8), "64438756"),
        (("664438769", 8), "67834466"),
        (("123456779", 8), "23456771"),
        (("123456987654", 6), "234561876549"),
        (("123456987653", 6), "234561356789"),
        (("733049910872815764", 5), "330479108928157"),
        (("563000655734469485", 4), "0365065073456944"),
    )
    for key, val in data:
        assert rev_rot(*key) == val


if __name__ == '__main__':
    test()
