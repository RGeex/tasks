"""
Здесь ваша задача — Создайте (красивую) рождественскую елку .

Вам не нужно проверять ошибки или неверные входные значения, все в порядке,
без подвохов, только один входной параметр и строка для возврата ;-)...

Так что же делать?

Первые три простых примера:

Input: 3 and Output:
  *
 ***
*****
 ###
 
 Input 9 and Output:
    *
   ***
  *****
   ***
  *****
 *******
  *****
 *******
*********
   ###
   
 Input 17 and Output:
      *
     ***
    *****
     ***
    *****
   *******
    *****
   *******
  *********
   *******
  *********
 ***********
  *********
 ***********
*************
     ###
     
Really nice trees, or what???! So merry Christmas;-)

Как видите, всегда корень, всегда шаги высотой 3, дерево никогда не меньше 3
(возврат "") и нет разницы для входных значений, таких как 15 или 17
(потому что (int) 15/3 = (int) 17/3) . Это справедливо для каждого входа и
каждого дерева. Строки разделяются \r\n и конечные пробелы не допускаются.
Думаю, больше сказать нечего - возможно, посмотрите и тесткейсы ;-)!

В начале есть несколько статических тестов и множество случайных тестов, если
вы отправите свое решение.
"""


def christmas_tree(n: int) -> str:
    """
    Рисует рождественскую ель.
    """
    c = [f'{["###", ""][not n // 3]:^{(x := (5 + 2 * (n // 3 - 1)))}}'.rstrip()]
    return '\r\n'.join([a for b in [[f"{'*' * (j + i * 2):^{x}}".rstrip() for j in (1, 3, 5)] for i in range(n // 3)] for a in b] + c)


def test() -> None:
    """
    Тестирование работы алгоритмов.
    """
    data = (
        (5,"  *\r\n ***\r\n*****\r\n ###"),
        (10,"    *\r\n   ***\r\n  *****\r\n   ***\r\n  *****\r\n *******\r\n  *****\r\n *******\r\n*********\r\n   ###"),
        (8,"   *\r\n  ***\r\n *****\r\n  ***\r\n *****\r\n*******\r\n  ###"),
        (2,""),
    )
    for key, val in data:
        assert christmas_tree(key) == val


if __name__ == '__main__':
    test()
