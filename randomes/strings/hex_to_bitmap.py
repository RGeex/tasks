"""
Большинство современных шрифтов, включая тот, который вы сейчас читаете, хранят каждый глиф в масштабируемом векторном формате .
Каждая линия, кривая и фигура наносятся на график с координатами, которые затем обсчитываются с помощью сложных математических
формул, которые мы не будем рассматривать в этой статье¹. Инфографика SVG Это отлично подходит для всех, поскольку такие
изображения можно масштабировать до бесконечности, и они никогда не теряют разрешения.

Однако SVG — изобретение XXI века. До появления векторов формат .bmp (растровое изображение) был популярен для графических
интерфейсов. Хотя он и не так совершенен, при правильном использовании он может быть чрезвычайно лаконичным для представления
данных². Хорошим примером является Unifont , массивный шрифт, содержащий «глифы для всех печатных кодовых точек базовой
многоязыковой кодировки Unicode»³.

Давайте рассмотрим, как основателям Unifont удалось вместить столько информации в один шрифт, на примере. Это «А»:

0041:0000000018242442427E424242420000

Слева — номер символа A в кодировке Unicode (U+0041), а справа — шестнадцатеричное значение двоичного представления этого
символа. Каждое число соответствует четырём битам⁴, а каждая последовательность из 32 цифр образует сетку 8x16 из единиц и
нулей. Всё это затем визуализируется как «включённый» или «выключённый» пиксель. Вот графическое представление символа A:


hex |  binary  |  visual
----|----------|--------- 
00  | 00000000 | ────────
00  | 00000000 | ────────
00  | 00000000 | ────────
00  | 00000000 | ────────
18  | 00011000 | ───██───
24  | 00100100 | ──█──█──
24  | 00100100 | ──█──█──
42  | 01000010 | ─█────█─
42  | 01000010 | ─█────█─
7E  | 01111110 | ─██████─
42  | 01000010 | ─█────█─
42  | 01000010 | ─█────█─
42  | 01000010 | ─█────█─
42  | 01000010 | ─█────█─
00  | 00000000 | ────────
00  | 00000000 | ────────

Круто, правда?

Именно это вы и сделаете для этой ката. Вы создадите функцию, которая, получая на вход шестнадцатеричное число в виде строки,
выведет 16-строчную строку из 8 бит, которая правильно отображает соответствующий символ⁵.
Сноски:

1: Если вам интересно узнать, какая математика используется, почитайте о кривой Безье.

2: Конечно, обычный файл .bmp не поддается простым манипуляциям... это было бы безумием.

3: Цитата с сайта. Кстати, когда я говорю, что Unifont огромен, я имею в виду именно это. В нём более 60 000 различных глифов!

4: 4 бита называются «полубайтом».

5: Я рассматривал возможность графического представления, но не хотел, чтобы в этой ката возникли проблемы с кодировкой
(использование обычных символов не сработает, поскольку все они имеют разную ширину). 
"""
import typing
import unittest


def hex_to_bitmap(hex_input: str) -> str:
    """
    Рисование символа из его HEX значения.
    """
    return ''.join([''.join(f'{int(x, 16):0>4b}' for x in hex_input[i:i+2]) + '\n' for i in range(0, len(hex_input), 2)])


def test(func: typing.Callable, data: tuple[tuple[typing.Any, typing.Any]]) -> None:
    """Тестирование работы алгоритмов с помощью unittest."""

    def test_func(func: typing.Callable, key: typing.Any, val: typing.Any) -> typing.Callable:
        """Создает кейсы для тестирования."""
        return lambda self: self.assertEqual(func(key), val)

    funcs = {f'test_{i}': test_func(func, key, val) for i, (key, val) in enumerate(data, 1)}
    suite = unittest.TestLoader().loadTestsFromTestCase(type('Tests', (unittest.TestCase,), funcs))

    unittest.TextTestRunner().run(suite)


if __name__ == '__main__':
    test(hex_to_bitmap, (
        ("0" * 32, "00000000\n" * 16),
        ("F" * 32, "11111111\n" * 16),
    ))
