"""
Задача:

Учитывая 2 строки. Необходимый:

  - Сократите пары одинаковых символов между первой и второй строками
    (Поиск символов следует производить от начала строки до первого совпадения).
  - Остальные символы второй строки вставьте в разрывы сокращений, не меняя
    порядка символов в строках.
        Если символы второй строки закончились, а в первой строке еще есть
        «переносы сокращений», вставлять в них ничего не нужно.
        Если разрывов нет, вставьте остаток второй строки в конец первой.
  - Верните полученную строку.

Пример:

  - Указаны строки: «abcddbef» и «sbbbdeghs».
  - Далее находим парные символы из первой строки во второй: «bbde».
  - Далее удаляем найденные символы из первой и второй строк, получаем:
    «acd.f» и «s..b..ghs» (точки обозначают удаленные символы,
    для наглядности исходные строки будут выглядеть так : «acdf» и «sbghs»).
  - Далее ставим оставшиеся символы из второй строки на место удаленных в
    первой строке, по 1 символу на каждый удаленный, это будет: «ascbdghf» и «s».
  - Переместите оставшиеся символы второй строки в конец первой, это будет: «ascbdghfs».

"""

from itertools import zip_longest


def combination1(s: str, w: str) -> str:
    """
    Комбинирует строки удаляя парные дубликаты.
    """
    (a, b), c = map(list, (s, w)), '\t'

    for i, x in enumerate(s):
        if x in b:
            a[i] = c
            b.remove(x)

    return ''.join(a + b for a, b in zip_longest(''.join(a).split(c), b, fillvalue=''))


def combination2(s: str, w: str) -> str:
    """
    Комбинирует строки удаляя парные дубликаты.
    """
    s, w = map(list, (s, w))
    for i in [i for i, x in enumerate(s) if x in w and not w.remove(x)]:
        s[i] = w.pop(0) if w else ''
    return ''.join(s + w)


def test() -> None:
    """
    Тестирование работы алгоритмов.
    """
    data = (
        (('', ''), ''),
        (('abcd', ''), 'abcd'),
        (('', 'abcd'), 'abcd'),
        (('a b c', ' '), 'ab c'),
        (('z', 'abcd'), 'zabcd'),
        (('abcd', 'z'), 'abcdz'),
        (('abcd', 'bz'), 'azcd'),
        (('abcddbef', 'sbbbdeghs'), 'ascbdghfs'),
    )
    for key, val in data:
        assert combination1(*key) == val
        assert combination2(*key) == val


if __name__ == '__main__':
    test()
